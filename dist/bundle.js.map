{"version":3,"file":"bundle.js","sources":["../node_modules/auto-curry/index.js","../src/index.ts"],"sourcesContent":["module.exports = function cu(fn) {\n  'use strict'\n\n  var args = [].slice.call(arguments)\n  var typeOfFn = typeof fn\n\n  if ('function' !== typeOfFn) throw new Error('auto-curry: Invalid parameter. Expected function, received ' + typeOfFn)\n  if (fn.length <= 1) return fn\n  if (args.length - 1 >= fn.length) return fn.apply(this, args.slice(1))\n\n  return function() {\n    return cu.apply(this, args.concat([].slice.call(arguments)))\n  };\n};\n","import cu from 'auto-curry'\nimport { Options, Handler, CustomEntry, UnobserveFn } from './index.types'\n\n/**\n * Given a set of options, DOM node and in and out of viewport handlers,\n * this function uses an IntersectionObserver to figure out whether\n * the DOM node is in viewport or not and calls the respective handler.\n * It is a curried function and expects the parameters in the not so\n * common order so as to make it easier to observe multiple DOM nodes\n * with the same settings/options and maybe even the same handlers.\n *\n * @param {object} opts - options to configure the viewport\n * and intersection threshold\n * @param {function} inHandler - fn to call when element is in viewport\n * for each given threshhold\n * @param {function} outHandler - fn to call when element leaves viewport\n * @param {Node} el - target element to observe\n *\n * @return {function} unobserve element function\n */\nfunction _observeElementInViewport(\n  opts: Options,\n  inHandler: Handler,\n  outHandler: Handler,\n  el: HTMLElement\n): UnobserveFn {\n  const defaultOptions: Options = {\n    // null for window, otherwise give css selector.\n    // el to be observed should be a child of element given by this selector\n    viewport: null,\n\n    // accepts px and %\n    modTop: '0px',\n    modRight: '0px',\n    modBottom: '0px',\n    modLeft: '0px',\n\n    // percentage of el that should intersect with viewport to consinder\n    // it \"in viewport\". 0 means on the 1st pixel intersection or exit,\n    // the respective handler will be called\n    threshold: [0]\n  }\n\n  const {\n    viewport,\n    modTop,\n    modLeft,\n    modBottom,\n    modRight,\n    threshold\n  }: Options = Object.assign({}, defaultOptions, opts)\n\n  // The mod 101 is to prevent threshold from being greater than 1\n  const thresholdArray: number[] = Array.isArray(threshold)\n    ? threshold.map(t => Math.floor(t % 101) / 100)\n    : [Math.floor(threshold % 101) / 100]\n\n  const minThreshold: number = Math.min(...thresholdArray)\n\n  if (!Array.isArray(threshold) && !(typeof threshold === 'number')) {\n    throw new Error('threshold should be a number or an array of numbers')\n  }\n\n  const intersectionObserverOptions: IntersectionObserverInit = {\n    root: viewport instanceof Node ? viewport : null,\n    rootMargin: `${modTop} ${modRight} ${modBottom} ${modLeft}`,\n    threshold: thresholdArray\n  }\n\n  const isDebugEnabled: boolean =\n    localStorage.debug &&\n    localStorage.debug.includes('observeElementInViewport')\n\n  if (isDebugEnabled) {\n    console.log('IntersectionObserver options', intersectionObserverOptions)\n  }\n\n  const cb = (entries: Array<CustomEntry>, observer: IntersectionObserver) => {\n    const entryForEl = entries.filter(entry => entry.target === el)[0]\n    const unobserve: UnobserveFn = () => observer.unobserve(el)\n\n    if (entryForEl) {\n      const { isIntersecting, intersectionRatio } = entryForEl\n\n      entryForEl.isInViewport =\n        isIntersecting && intersectionRatio >= minThreshold\n\n      if (entryForEl.isInViewport) {\n        inHandler(entryForEl, unobserve, el)\n      } else {\n        outHandler(entryForEl, unobserve, el)\n      }\n    }\n  }\n\n  const observer = new IntersectionObserver(cb, intersectionObserverOptions)\n\n  observer.observe(el)\n\n  return () => observer.unobserve(el)\n}\n\nexport const observeElementInViewport = cu(_observeElementInViewport)\n\nexport const isInViewport = cu(async (el: HTMLElement, opts: Options) => {\n  return new Promise((resolve, reject) => {\n    try {\n      observeElementInViewport(\n        opts,\n        <Handler>((_, unobserve) => {\n          unobserve()\n          resolve(true)\n        }),\n        <Handler>((_, unobserve) => {\n          unobserve()\n          resolve(false)\n        }),\n        el\n      )\n    } catch (e) {\n      reject(e)\n    }\n  })\n})\n"],"names":["cu"],"mappings":"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"}